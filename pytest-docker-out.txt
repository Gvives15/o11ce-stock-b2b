FFFFF                                                                    [100%]
=================================== FAILURES ===================================
___________ TestGSEC01AccessControl.test_admin_can_access_all_sales ____________

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:181: in _get_response
    callback, callback_args, callback_kwargs = self.resolve_request(request)
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:313: in resolve_request
    resolver_match = resolver.resolve(request.path_info)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:686: in resolve
    for pattern in self.url_patterns:
                   ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:738: in url_patterns
    patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/corsheaders/middleware.py:53: in __call__
    result = self.get_response(request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

self = <tests.security.pos.test_pos_security_access.TestGSEC01AccessControl testMethod=test_admin_can_access_all_sales>

    def setUp(self):
        """Configuracin inicial para los tests de seguridad G-SEC-01"""
        # Crear usuarios con diferentes roles
        self.seller1 = User.objects.create_user(
            username='seller1',
            password='testpass123',
            email='seller1@test.com'
        )
    
        self.seller2 = User.objects.create_user(
            username='seller2',
            password='testpass123',
            email='seller2@test.com'
        )
    
        self.admin = User.objects.create_user(
            username='admin',
            password='testpass123',
            email='admin@test.com'
        )
    
        # Configurar permisos usando get_or_create para evitar duplicados
        seller1_scope, created = UserScope.objects.get_or_create(
            user=self.seller1,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller1_scope.has_scope_reports = False
            seller1_scope.save()
    
        seller2_scope, created = UserScope.objects.get_or_create(
            user=self.seller2,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller2_scope.has_scope_reports = False
            seller2_scope.save()
    
        admin_scope, created = UserScope.objects.get_or_create(
            user=self.admin,
            defaults={'has_scope_reports': True}
        )
        if not created:
            admin_scope.has_scope_reports = True
            admin_scope.save()
    
        # Verificar que los scopes estn correctamente asignados
        self.seller1.refresh_from_db()
        self.seller2.refresh_from_db()
        self.admin.refresh_from_db()
    
        # Crear datos de prueba
        self.warehouse = Warehouse.objects.create(name='Almacn Test')
    
        self.product = Product.objects.create(
            name='Producto Test',
            code='TEST001',
            price=Decimal('10.00')
        )
    
        self.customer = Customer.objects.create(
            name='Cliente Test',
            segment='retail'
        )
    
        # Crear lotes con stock usando el servicio de entrada
        from apps.stock.services import record_entry
    
        entry1 = record_entry(
            product_id=self.product.id,
            lot_code='LOT001',
            expiry_date=date.today() + timedelta(days=30),
            qty=Decimal('100.00'),
            unit_cost=Decimal('8.00'),
            user_id=self.seller1.id,
            warehouse_id=self.warehouse.id
        )
        self.lot = entry1.lot
    
        # Crear ventas reales usando el endpoint de API
        from django.test import Client
        self.client = Client()
    
        # Venta del seller1
        self.client.force_login(self.seller1)
>       response1 = self.client.post(
            '/api/v1/pos/sale',
            data={
                'items': [
                    {
                        'product_id': self.product.id,
                        'qty': '10.00',
                        'unit_price': '10.00'
                    }
                ]
            },
            content_type='application/json'
        )

tests/security/pos/test_pos_security_access.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/test/client.py:1070: in post
    response = super().post(
/usr/local/lib/python3.11/site-packages/django/test/client.py:490: in post
    return self.generic(
/usr/local/lib/python3.11/site-packages/django/test/client.py:617: in generic
    return self.request(**r)
           ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:1008: in request
    response = self.handler(environ)
               ^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:186: in __call__
    response = self.get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/__init__.py:478: in sentry_patched_get_response
    rv = old_get_response(self, request)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:140: in get_response
    response = self._middleware_chain(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
<frozen importlib._bootstrap>:1147: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:690: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:940: in exec_module
    ???
<frozen importlib._bootstrap>:241: in _call_with_frames_removed
    ???
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError
__________ TestGSEC01AccessControl.test_nonexistent_sale_returns_404 ___________

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:181: in _get_response
    callback, callback_args, callback_kwargs = self.resolve_request(request)
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:313: in resolve_request
    resolver_match = resolver.resolve(request.path_info)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:686: in resolve
    for pattern in self.url_patterns:
                   ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:738: in url_patterns
    patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/corsheaders/middleware.py:53: in __call__
    result = self.get_response(request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

self = <tests.security.pos.test_pos_security_access.TestGSEC01AccessControl testMethod=test_nonexistent_sale_returns_404>

    def setUp(self):
        """Configuracin inicial para los tests de seguridad G-SEC-01"""
        # Crear usuarios con diferentes roles
        self.seller1 = User.objects.create_user(
            username='seller1',
            password='testpass123',
            email='seller1@test.com'
        )
    
        self.seller2 = User.objects.create_user(
            username='seller2',
            password='testpass123',
            email='seller2@test.com'
        )
    
        self.admin = User.objects.create_user(
            username='admin',
            password='testpass123',
            email='admin@test.com'
        )
    
        # Configurar permisos usando get_or_create para evitar duplicados
        seller1_scope, created = UserScope.objects.get_or_create(
            user=self.seller1,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller1_scope.has_scope_reports = False
            seller1_scope.save()
    
        seller2_scope, created = UserScope.objects.get_or_create(
            user=self.seller2,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller2_scope.has_scope_reports = False
            seller2_scope.save()
    
        admin_scope, created = UserScope.objects.get_or_create(
            user=self.admin,
            defaults={'has_scope_reports': True}
        )
        if not created:
            admin_scope.has_scope_reports = True
            admin_scope.save()
    
        # Verificar que los scopes estn correctamente asignados
        self.seller1.refresh_from_db()
        self.seller2.refresh_from_db()
        self.admin.refresh_from_db()
    
        # Crear datos de prueba
        self.warehouse = Warehouse.objects.create(name='Almacn Test')
    
        self.product = Product.objects.create(
            name='Producto Test',
            code='TEST001',
            price=Decimal('10.00')
        )
    
        self.customer = Customer.objects.create(
            name='Cliente Test',
            segment='retail'
        )
    
        # Crear lotes con stock usando el servicio de entrada
        from apps.stock.services import record_entry
    
        entry1 = record_entry(
            product_id=self.product.id,
            lot_code='LOT001',
            expiry_date=date.today() + timedelta(days=30),
            qty=Decimal('100.00'),
            unit_cost=Decimal('8.00'),
            user_id=self.seller1.id,
            warehouse_id=self.warehouse.id
        )
        self.lot = entry1.lot
    
        # Crear ventas reales usando el endpoint de API
        from django.test import Client
        self.client = Client()
    
        # Venta del seller1
        self.client.force_login(self.seller1)
>       response1 = self.client.post(
            '/api/v1/pos/sale',
            data={
                'items': [
                    {
                        'product_id': self.product.id,
                        'qty': '10.00',
                        'unit_price': '10.00'
                    }
                ]
            },
            content_type='application/json'
        )

tests/security/pos/test_pos_security_access.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/test/client.py:1070: in post
    response = super().post(
/usr/local/lib/python3.11/site-packages/django/test/client.py:490: in post
    return self.generic(
/usr/local/lib/python3.11/site-packages/django/test/client.py:617: in generic
    return self.request(**r)
           ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:1008: in request
    response = self.handler(environ)
               ^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:186: in __call__
    response = self.get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/__init__.py:478: in sentry_patched_get_response
    rv = old_get_response(self, request)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:140: in get_response
    response = self._middleware_chain(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
<frozen importlib._bootstrap>:1147: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:690: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:940: in exec_module
    ???
<frozen importlib._bootstrap>:241: in _call_with_frames_removed
    ???
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError
___________ TestGSEC01AccessControl.test_seller_can_access_own_sale ____________

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:181: in _get_response
    callback, callback_args, callback_kwargs = self.resolve_request(request)
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:313: in resolve_request
    resolver_match = resolver.resolve(request.path_info)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:686: in resolve
    for pattern in self.url_patterns:
                   ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:738: in url_patterns
    patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/corsheaders/middleware.py:53: in __call__
    result = self.get_response(request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

self = <tests.security.pos.test_pos_security_access.TestGSEC01AccessControl testMethod=test_seller_can_access_own_sale>

    def setUp(self):
        """Configuracin inicial para los tests de seguridad G-SEC-01"""
        # Crear usuarios con diferentes roles
        self.seller1 = User.objects.create_user(
            username='seller1',
            password='testpass123',
            email='seller1@test.com'
        )
    
        self.seller2 = User.objects.create_user(
            username='seller2',
            password='testpass123',
            email='seller2@test.com'
        )
    
        self.admin = User.objects.create_user(
            username='admin',
            password='testpass123',
            email='admin@test.com'
        )
    
        # Configurar permisos usando get_or_create para evitar duplicados
        seller1_scope, created = UserScope.objects.get_or_create(
            user=self.seller1,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller1_scope.has_scope_reports = False
            seller1_scope.save()
    
        seller2_scope, created = UserScope.objects.get_or_create(
            user=self.seller2,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller2_scope.has_scope_reports = False
            seller2_scope.save()
    
        admin_scope, created = UserScope.objects.get_or_create(
            user=self.admin,
            defaults={'has_scope_reports': True}
        )
        if not created:
            admin_scope.has_scope_reports = True
            admin_scope.save()
    
        # Verificar que los scopes estn correctamente asignados
        self.seller1.refresh_from_db()
        self.seller2.refresh_from_db()
        self.admin.refresh_from_db()
    
        # Crear datos de prueba
        self.warehouse = Warehouse.objects.create(name='Almacn Test')
    
        self.product = Product.objects.create(
            name='Producto Test',
            code='TEST001',
            price=Decimal('10.00')
        )
    
        self.customer = Customer.objects.create(
            name='Cliente Test',
            segment='retail'
        )
    
        # Crear lotes con stock usando el servicio de entrada
        from apps.stock.services import record_entry
    
        entry1 = record_entry(
            product_id=self.product.id,
            lot_code='LOT001',
            expiry_date=date.today() + timedelta(days=30),
            qty=Decimal('100.00'),
            unit_cost=Decimal('8.00'),
            user_id=self.seller1.id,
            warehouse_id=self.warehouse.id
        )
        self.lot = entry1.lot
    
        # Crear ventas reales usando el endpoint de API
        from django.test import Client
        self.client = Client()
    
        # Venta del seller1
        self.client.force_login(self.seller1)
>       response1 = self.client.post(
            '/api/v1/pos/sale',
            data={
                'items': [
                    {
                        'product_id': self.product.id,
                        'qty': '10.00',
                        'unit_price': '10.00'
                    }
                ]
            },
            content_type='application/json'
        )

tests/security/pos/test_pos_security_access.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/test/client.py:1070: in post
    response = super().post(
/usr/local/lib/python3.11/site-packages/django/test/client.py:490: in post
    return self.generic(
/usr/local/lib/python3.11/site-packages/django/test/client.py:617: in generic
    return self.request(**r)
           ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:1008: in request
    response = self.handler(environ)
               ^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:186: in __call__
    response = self.get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/__init__.py:478: in sentry_patched_get_response
    rv = old_get_response(self, request)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:140: in get_response
    response = self._middleware_chain(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
<frozen importlib._bootstrap>:1147: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:690: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:940: in exec_module
    ???
<frozen importlib._bootstrap>:241: in _call_with_frames_removed
    ???
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError
_________ TestGSEC01AccessControl.test_seller_cannot_access_other_sale _________

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:181: in _get_response
    callback, callback_args, callback_kwargs = self.resolve_request(request)
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:313: in resolve_request
    resolver_match = resolver.resolve(request.path_info)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:686: in resolve
    for pattern in self.url_patterns:
                   ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:738: in url_patterns
    patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/corsheaders/middleware.py:53: in __call__
    result = self.get_response(request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

self = <tests.security.pos.test_pos_security_access.TestGSEC01AccessControl testMethod=test_seller_cannot_access_other_sale>

    def setUp(self):
        """Configuracin inicial para los tests de seguridad G-SEC-01"""
        # Crear usuarios con diferentes roles
        self.seller1 = User.objects.create_user(
            username='seller1',
            password='testpass123',
            email='seller1@test.com'
        )
    
        self.seller2 = User.objects.create_user(
            username='seller2',
            password='testpass123',
            email='seller2@test.com'
        )
    
        self.admin = User.objects.create_user(
            username='admin',
            password='testpass123',
            email='admin@test.com'
        )
    
        # Configurar permisos usando get_or_create para evitar duplicados
        seller1_scope, created = UserScope.objects.get_or_create(
            user=self.seller1,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller1_scope.has_scope_reports = False
            seller1_scope.save()
    
        seller2_scope, created = UserScope.objects.get_or_create(
            user=self.seller2,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller2_scope.has_scope_reports = False
            seller2_scope.save()
    
        admin_scope, created = UserScope.objects.get_or_create(
            user=self.admin,
            defaults={'has_scope_reports': True}
        )
        if not created:
            admin_scope.has_scope_reports = True
            admin_scope.save()
    
        # Verificar que los scopes estn correctamente asignados
        self.seller1.refresh_from_db()
        self.seller2.refresh_from_db()
        self.admin.refresh_from_db()
    
        # Crear datos de prueba
        self.warehouse = Warehouse.objects.create(name='Almacn Test')
    
        self.product = Product.objects.create(
            name='Producto Test',
            code='TEST001',
            price=Decimal('10.00')
        )
    
        self.customer = Customer.objects.create(
            name='Cliente Test',
            segment='retail'
        )
    
        # Crear lotes con stock usando el servicio de entrada
        from apps.stock.services import record_entry
    
        entry1 = record_entry(
            product_id=self.product.id,
            lot_code='LOT001',
            expiry_date=date.today() + timedelta(days=30),
            qty=Decimal('100.00'),
            unit_cost=Decimal('8.00'),
            user_id=self.seller1.id,
            warehouse_id=self.warehouse.id
        )
        self.lot = entry1.lot
    
        # Crear ventas reales usando el endpoint de API
        from django.test import Client
        self.client = Client()
    
        # Venta del seller1
        self.client.force_login(self.seller1)
>       response1 = self.client.post(
            '/api/v1/pos/sale',
            data={
                'items': [
                    {
                        'product_id': self.product.id,
                        'qty': '10.00',
                        'unit_price': '10.00'
                    }
                ]
            },
            content_type='application/json'
        )

tests/security/pos/test_pos_security_access.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/test/client.py:1070: in post
    response = super().post(
/usr/local/lib/python3.11/site-packages/django/test/client.py:490: in post
    return self.generic(
/usr/local/lib/python3.11/site-packages/django/test/client.py:617: in generic
    return self.request(**r)
           ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:1008: in request
    response = self.handler(environ)
               ^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:186: in __call__
    response = self.get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/__init__.py:478: in sentry_patched_get_response
    rv = old_get_response(self, request)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:140: in get_response
    response = self._middleware_chain(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
<frozen importlib._bootstrap>:1147: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:690: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:940: in exec_module
    ???
<frozen importlib._bootstrap>:241: in _call_with_frames_removed
    ???
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError
__________ TestGSEC01AccessControl.test_unauthenticated_access_denied __________

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:181: in _get_response
    callback, callback_args, callback_kwargs = self.resolve_request(request)
                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:313: in resolve_request
    resolver_match = resolver.resolve(request.path_info)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:686: in resolve
    for pattern in self.url_patterns:
                   ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:738: in url_patterns
    patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/corsheaders/middleware.py:53: in __call__
    result = self.get_response(request)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/pos/sale'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)
                       ^^^^^^^^^^^^^^^^^^^^^

/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/middleware.py:177: in __call__
    return f(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/deprecation.py:134: in __call__
    response = response or self.get_response(request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError

During handling of the above exception, another exception occurred:

self = <tests.security.pos.test_pos_security_access.TestGSEC01AccessControl testMethod=test_unauthenticated_access_denied>

    def setUp(self):
        """Configuracin inicial para los tests de seguridad G-SEC-01"""
        # Crear usuarios con diferentes roles
        self.seller1 = User.objects.create_user(
            username='seller1',
            password='testpass123',
            email='seller1@test.com'
        )
    
        self.seller2 = User.objects.create_user(
            username='seller2',
            password='testpass123',
            email='seller2@test.com'
        )
    
        self.admin = User.objects.create_user(
            username='admin',
            password='testpass123',
            email='admin@test.com'
        )
    
        # Configurar permisos usando get_or_create para evitar duplicados
        seller1_scope, created = UserScope.objects.get_or_create(
            user=self.seller1,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller1_scope.has_scope_reports = False
            seller1_scope.save()
    
        seller2_scope, created = UserScope.objects.get_or_create(
            user=self.seller2,
            defaults={'has_scope_reports': False}
        )
        if not created:
            seller2_scope.has_scope_reports = False
            seller2_scope.save()
    
        admin_scope, created = UserScope.objects.get_or_create(
            user=self.admin,
            defaults={'has_scope_reports': True}
        )
        if not created:
            admin_scope.has_scope_reports = True
            admin_scope.save()
    
        # Verificar que los scopes estn correctamente asignados
        self.seller1.refresh_from_db()
        self.seller2.refresh_from_db()
        self.admin.refresh_from_db()
    
        # Crear datos de prueba
        self.warehouse = Warehouse.objects.create(name='Almacn Test')
    
        self.product = Product.objects.create(
            name='Producto Test',
            code='TEST001',
            price=Decimal('10.00')
        )
    
        self.customer = Customer.objects.create(
            name='Cliente Test',
            segment='retail'
        )
    
        # Crear lotes con stock usando el servicio de entrada
        from apps.stock.services import record_entry
    
        entry1 = record_entry(
            product_id=self.product.id,
            lot_code='LOT001',
            expiry_date=date.today() + timedelta(days=30),
            qty=Decimal('100.00'),
            unit_cost=Decimal('8.00'),
            user_id=self.seller1.id,
            warehouse_id=self.warehouse.id
        )
        self.lot = entry1.lot
    
        # Crear ventas reales usando el endpoint de API
        from django.test import Client
        self.client = Client()
    
        # Venta del seller1
        self.client.force_login(self.seller1)
>       response1 = self.client.post(
            '/api/v1/pos/sale',
            data={
                'items': [
                    {
                        'product_id': self.product.id,
                        'qty': '10.00',
                        'unit_price': '10.00'
                    }
                ]
            },
            content_type='application/json'
        )

tests/security/pos/test_pos_security_access.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/test/client.py:1070: in post
    response = super().post(
/usr/local/lib/python3.11/site-packages/django/test/client.py:490: in post
    return self.generic(
/usr/local/lib/python3.11/site-packages/django/test/client.py:617: in generic
    return self.request(**r)
           ^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:1008: in request
    response = self.handler(environ)
               ^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/test/client.py:186: in __call__
    response = self.get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/sentry_sdk/integrations/django/__init__.py:478: in sentry_patched_get_response
    rv = old_get_response(self, request)
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:140: in get_response
    response = self._middleware_chain(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:57: in inner
    response = response_for_exception(request, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:140: in response_for_exception
    response = handle_uncaught_exception(
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:184: in handle_uncaught_exception
    callback = resolver.resolve_error_handler(500)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:752: in resolve_error_handler
    callback = getattr(self.urlconf_module, "handler%s" % view_type, None)
                       ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/utils/functional.py:47: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
                                         ^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:731: in urlconf_module
    return import_module(self.urlconf_name)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.11/importlib/__init__.py:126: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
<frozen importlib._bootstrap>:1204: in _gcd_import
    ???
<frozen importlib._bootstrap>:1176: in _find_and_load
    ???
<frozen importlib._bootstrap>:1147: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:690: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:940: in exec_module
    ???
<frozen importlib._bootstrap>:241: in _call_with_frames_removed
    ???
config/urls.py:23: in <module>
    from api import api
api/__init__.py:23: in <module>
    from apps.pos.api import router as pos_router
apps/pos/api.py:22: in <module>
    from .events import (
apps/pos/events.py:36: in <module>
    @dataclass
     ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1232: in dataclass
    return wrap(cls)
           ^^^^^^^^^
/usr/local/lib/python3.11/dataclasses.py:1222: in wrap
    return _process_class(cls, init, repr, eq, order, unsafe_hash,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'apps.pos.events.SaleCreated'>, init = True, repr = True, eq = True
order = False, unsafe_hash = False, frozen = False, match_args = True
kw_only = False, slots = False, weakref_slot = False

    def _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,
                       match_args, kw_only, slots, weakref_slot):
        # Now that dicts retain insertion order, there's no reason to use
        # an ordered dict.  I am leveraging that ordering here, because
        # derived class fields overwrite base class fields, but the order
        # is defined by the base class, which is found first.
        fields = {}
    
        if cls.__module__ in sys.modules:
            globals = sys.modules[cls.__module__].__dict__
        else:
            # Theoretically this can happen if someone writes
            # a custom string to cls.__module__.  In which case
            # such dataclass won't be fully introspectable
            # (w.r.t. typing.get_type_hints) but will still function
            # correctly.
            globals = {}
    
        setattr(cls, _PARAMS, _DataclassParams(init, repr, eq, order,
                                               unsafe_hash, frozen))
    
        # Find our base classes in reverse MRO order, and exclude
        # ourselves.  In reversed order so that more derived classes
        # override earlier field definitions in base classes.  As long as
        # we're iterating over them, see if any are frozen.
        any_frozen_base = False
        has_dataclass_bases = False
        for b in cls.__mro__[-1:0:-1]:
            # Only process classes that have been processed by our
            # decorator.  That is, they have a _FIELDS attribute.
            base_fields = getattr(b, _FIELDS, None)
            if base_fields is not None:
                has_dataclass_bases = True
                for f in base_fields.values():
                    fields[f.name] = f
                if getattr(b, _PARAMS).frozen:
                    any_frozen_base = True
    
        # Annotations that are defined in this class (not in base
        # classes).  If __annotations__ isn't present, then this class
        # adds no new annotations.  We use this to compute fields that are
        # added by this class.
        #
        # Fields are found from cls_annotations, which is guaranteed to be
        # ordered.  Default values are from class attributes, if a field
        # has a default.  If the default value is a Field(), then it
        # contains additional info beyond (and possibly including) the
        # actual default value.  Pseudo-fields ClassVars and InitVars are
        # included, despite the fact that they're not real fields.  That's
        # dealt with later.
        cls_annotations = cls.__dict__.get('__annotations__', {})
    
        # Now find fields in our class.  While doing so, validate some
        # things, and set the default values (as class attributes) where
        # we can.
        cls_fields = []
        # Get a reference to this module for the _is_kw_only() test.
        KW_ONLY_seen = False
        dataclasses = sys.modules[__name__]
        for name, type in cls_annotations.items():
            # See if this is a marker to change the value of kw_only.
            if (_is_kw_only(type, dataclasses)
                or (isinstance(type, str)
                    and _is_type(type, cls, dataclasses, dataclasses.KW_ONLY,
                                 _is_kw_only))):
                # Switch the default to kw_only=True, and ignore this
                # annotation: it's not a real field.
                if KW_ONLY_seen:
                    raise TypeError(f'{name!r} is KW_ONLY, but KW_ONLY '
                                    'has already been specified')
                KW_ONLY_seen = True
                kw_only = True
            else:
                # Otherwise it's a field of some type.
                cls_fields.append(_get_field(cls, name, type, kw_only))
    
        for f in cls_fields:
            fields[f.name] = f
    
            # If the class attribute (which is the default value for this
            # field) exists and is of type 'Field', replace it with the
            # real default.  This is so that normal class introspection
            # sees a real default value, not a Field.
            if isinstance(getattr(cls, f.name, None), Field):
                if f.default is MISSING:
                    # If there's no default, delete the class attribute.
                    # This happens if we specify field(repr=False), for
                    # example (that is, we specified a field object, but
                    # no default value).  Also if we're using a default
                    # factory.  The class attribute should not be set at
                    # all in the post-processed class.
                    delattr(cls, f.name)
                else:
                    setattr(cls, f.name, f.default)
    
        # Do we have any Field members that don't also have annotations?
        for name, value in cls.__dict__.items():
            if isinstance(value, Field) and not name in cls_annotations:
                raise TypeError(f'{name!r} is a field but has no type annotation')
    
        # Check rules that apply if we are derived from any dataclasses.
        if has_dataclass_bases:
            # Raise an exception if any of our bases are frozen, but we're not.
            if any_frozen_base and not frozen:
>               raise TypeError('cannot inherit non-frozen dataclass from a '
                                'frozen one')
E               TypeError: cannot inherit non-frozen dataclass from a frozen one

/usr/local/lib/python3.11/dataclasses.py:988: TypeError
=============================== warnings summary ===============================
../usr/local/lib/python3.11/site-packages/django/conf/__init__.py:251
../usr/local/lib/python3.11/site-packages/django/conf/__init__.py:251
  /usr/local/lib/python3.11/site-packages/django/conf/__init__.py:251: RemovedInDjango51Warning: The STATICFILES_STORAGE setting is deprecated. Use STORAGES instead.
    warnings.warn(STATICFILES_STORAGE_DEPRECATED_MSG, RemovedInDjango51Warning)

apps/core/apps.py:21
  /app/apps/core/apps.py:21: RuntimeWarning: coroutine 'EventBus.initialize' was never awaited
    EventBus.initialize(event_bus_config)
  Enable tracemalloc to get traceback where the object was allocated.
  See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.

tests/security/pos/test_pos_security_access.py::TestGSEC01AccessControl::test_admin_can_access_all_sales
tests/security/pos/test_pos_security_access.py::TestGSEC01AccessControl::test_admin_can_access_all_sales
tests/security/pos/test_pos_security_access.py::TestGSEC01AccessControl::test_admin_can_access_all_sales
  /usr/local/lib/python3.11/site-packages/pydantic/_internal/_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/security/pos/test_pos_security_access.py::TestGSEC01AccessControl::test_admin_can_access_all_sales
FAILED tests/security/pos/test_pos_security_access.py::TestGSEC01AccessControl::test_nonexistent_sale_returns_404
FAILED tests/security/pos/test_pos_security_access.py::TestGSEC01AccessControl::test_seller_can_access_own_sale
FAILED tests/security/pos/test_pos_security_access.py::TestGSEC01AccessControl::test_seller_cannot_access_other_sale
FAILED tests/security/pos/test_pos_security_access.py::TestGSEC01AccessControl::test_unauthenticated_access_denied
5 failed, 6 warnings in 122.07s (0:02:02)
